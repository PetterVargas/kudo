---
title: Est√°ndar de Codificaci√≥n Segura
description: Est√°ndares para la codificaci√≥n segura de aplicaciones.
---

## üìã Informaci√≥n General

**Documento:** Est√°ndar de Codificaci√≥n Segura  
**Versi√≥n:** 1.0.0  
**Fecha:** Enero 2025  
**Clasificaci√≥n:** Confidencial  
**Audiencia:** Desarrolladores, arquitectos de software y equipos de QA de DivisionCero

## üéØ Prop√≥sito

Definir los est√°ndares t√©cnicos y mejores pr√°cticas de codificaci√≥n segura que deben seguir todos los desarrolladores de DivisionCero para prevenir vulnerabilidades de seguridad comunes y garantizar que el c√≥digo sea resistente a ataques. Este est√°ndar complementa la Pol√≠tica de Desarrollo Seguro estableciendo requisitos t√©cnicos espec√≠ficos.

## üè¢ Alcance

Este est√°ndar aplica a:
- Todo el c√≥digo fuente desarrollado para la plataforma SaaS de DivisionCero
- Aplicaciones web, APIs REST/GraphQL, microservicios y componentes backend
- C√≥digo frontend incluyendo aplicaciones SPA y componentes JavaScript
- Scripts de automatizaci√≥n, infraestructura como c√≥digo (IaC) y configuraciones
- Bibliotecas internas y componentes reutilizables
- Integraciones con servicios externos y APIs de terceros

## üìö Definiciones

- **Inyecci√≥n de C√≥digo:** Vulnerabilidad que permite ejecutar c√≥digo malicioso en el sistema
- **XSS:** Cross-Site Scripting - Inyecci√≥n de scripts en aplicaciones web
- **CSRF:** Cross-Site Request Forgery - Ataques que explotan la confianza de un sitio
- **IDOR:** Insecure Direct Object Reference - Acceso no autorizado a objetos
- **Sanitizaci√≥n:** Proceso de limpieza y validaci√≥n de datos de entrada
- **Principio de Menor Privilegio:** Otorgar solo los permisos m√≠nimos necesarios
- **Secrets:** Informaci√≥n sensible como claves API, tokens y credenciales

## üõ°Ô∏è Pol√≠tica

### Validaci√≥n y Sanitizaci√≥n de Entrada

#### Validaci√≥n de Datos
- **Validaci√≥n del lado servidor:** Toda validaci√≥n cr√≠tica debe realizarse en el backend
- **Lista blanca sobre lista negra:** Definir qu√© est√° permitido en lugar de qu√© est√° prohibido
- **Validaci√≥n de tipo de dato:** Verificar tipos, rangos y formatos esperados
- **Encoding de salida:** Codificar datos antes de mostrarlos al usuario

```javascript
// ‚úÖ Correcto: Validaci√≥n robusta
function validateEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!email || typeof email !== 'string') {
        throw new Error('Email inv√°lido');
    }
    return emailRegex.test(email.trim());
}

// ‚ùå Incorrecto: Sin validaci√≥n
function processEmail(email) {
    return email; // Vulnerable a inyecci√≥n
}
```

#### Prevenci√≥n de Inyecci√≥n SQL
- **Consultas parametrizadas:** Usar siempre prepared statements
- **ORM seguro:** Utilizar ORMs que manejen sanitizaci√≥n autom√°tica
- **Validaci√≥n de entrada:** Nunca construir queries con concatenaci√≥n de strings

```sql
-- ‚úÖ Correcto: Query parametrizada
SELECT * FROM users WHERE email = ? AND status = ?

-- ‚ùå Incorrecto: Concatenaci√≥n directa
SELECT * FROM users WHERE email = '" + userEmail + "'
```

### Gesti√≥n de Autenticaci√≥n y Sesiones

#### Autenticaci√≥n Robusta
- **Hashing de contrase√±as:** Usar bcrypt, scrypt o Argon2 con salt apropiado
- **M√∫ltiples factores:** Implementar 2FA/MFA para cuentas privilegiadas
- **Bloqueo por intentos:** Limitar intentos de login fallidos
- **Tokens seguros:** Usar JWT con algoritmos seguros (RS256, no HS256 con secrets d√©biles)

```javascript
// ‚úÖ Correcto: Hashing seguro
const bcrypt = require('bcrypt');
const saltRounds = 12;

async function hashPassword(password) {
    return await bcrypt.hash(password, saltRounds);
}

// ‚ùå Incorrecto: Almacenamiento en texto plano
function storePassword(password) {
    return password; // Nunca almacenar contrase√±as en texto plano
}
```

#### Gesti√≥n de Sesiones
- **Tokens de sesi√≥n seguros:** Generar tokens criptogr√°ficamente seguros
- **Expiraci√≥n apropiada:** Configurar timeouts de sesi√≥n razonables
- **Invalidaci√≥n:** Implementar logout que invalide completamente la sesi√≥n
- **Rotaci√≥n de tokens:** Renovar tokens peri√≥dicamente

### Manejo de Errores y Logging

#### Manejo Seguro de Errores
- **Informaci√≥n m√≠nima:** No exponer detalles internos en mensajes de error
- **Logging completo:** Registrar errores detalladamente para debugging interno
- **C√≥digos de estado apropiados:** Usar c√≥digos HTTP correctos sin revelar arquitectura

```javascript
// ‚úÖ Correcto: Error handling seguro
try {
    await processPayment(paymentData);
} catch (error) {
    logger.error('Payment processing failed', { 
        userId: user.id, 
        error: error.message,
        timestamp: new Date().toISOString()
    });
    
    // Usuario solo ve mensaje gen√©rico
    res.status(500).json({ 
        error: 'Error procesando el pago. Intente nuevamente.' 
    });
}

// ‚ùå Incorrecto: Exposici√≥n de informaci√≥n interna
catch (error) {
    res.status(500).json({ error: error.stack }); // Revela arquitectura
}
```

### Comunicaciones Seguras

#### Encriptaci√≥n en Tr√°nsito
- **HTTPS obligatorio:** Todas las comunicaciones deben usar TLS 1.2+
- **HSTS headers:** Implementar HTTP Strict Transport Security
- **Certificate pinning:** Para conexiones cr√≠ticas con APIs externas

#### Encriptaci√≥n en Reposo
- **Datos sensibles:** Encriptar PII, tokens y secretos en base de datos
- **Claves de encriptaci√≥n:** Usar servicios de gesti√≥n de claves (AWS KMS, HashiCorp Vault)
- **Rotaci√≥n de claves:** Implementar rotaci√≥n autom√°tica de claves de encriptaci√≥n

### Gesti√≥n de Secretos y Configuraci√≥n

#### Secretos y Credenciales
- **Variables de entorno:** Nunca hardcodear secretos en el c√≥digo
- **Vaults de secretos:** Usar soluciones especializadas para gesti√≥n de secretos
- **Rotaci√≥n autom√°tica:** Implementar rotaci√≥n autom√°tica de API keys y tokens
- **Principio de menor privilegio:** Cada servicio solo debe tener acceso a sus secretos necesarios

```javascript
// ‚úÖ Correcto: Uso de variables de entorno
const dbPassword = process.env.DB_PASSWORD;
const apiKey = process.env.EXTERNAL_API_KEY;

// ‚ùå Incorrecto: Secretos hardcodeados
const dbPassword = "mySecretPassword123"; // Nunca hacer esto
const apiKey = "sk-1234567890abcdef"; // Vulnerable
```

### Control de Acceso y Autorizaci√≥n

#### Implementaci√≥n de RBAC
- **Verificaci√≥n en cada endpoint:** Validar permisos en todas las rutas protegidas
- **Contexto de autorizaci√≥n:** Considerar contexto del usuario y recurso solicitado
- **Principio de menor privilegio:** Otorgar solo permisos m√≠nimos necesarios

```javascript
// ‚úÖ Correcto: Verificaci√≥n de autorizaci√≥n
async function updateUser(userId, userData, currentUser) {
    // Verificar que el usuario puede modificar este recurso
    if (currentUser.id !== userId && !currentUser.hasRole('admin')) {
        throw new ForbiddenError('No autorizado para modificar este usuario');
    }
    
    return await userService.update(userId, userData);
}
```

### Seguridad Frontend

#### Prevenci√≥n XSS
- **Content Security Policy:** Implementar CSP headers restrictivos
- **Sanitizaci√≥n de HTML:** Usar bibliotecas como DOMPurify para contenido din√°mico
- **Escapado de caracteres:** Escapar datos antes de insertar en DOM

#### Protecci√≥n CSRF
- **Tokens CSRF:** Implementar tokens anti-CSRF en formularios
- **SameSite cookies:** Configurar cookies con atributo SameSite
- **Verificaci√≥n de origen:** Validar headers Origin y Referer

### An√°lisis y Testing de Seguridad

#### Herramientas Obligatorias
- **SAST:** An√°lisis est√°tico integrado en CI/CD (SonarQube, Checkmarx)
- **Dependency checking:** Escaneo de vulnerabilidades en dependencias (Snyk, OWASP Dependency Check)
- **Secret scanning:** Detecci√≥n de secretos hardcodeados (GitLeaks, TruffleHog)

#### M√©tricas de Calidad
- **Cobertura de c√≥digo:** M√≠nimo 80% cobertura con tests de seguridad incluidos
- **Complejidad ciclom√°tica:** Mantener funciones con complejidad < 10
- **Deuda t√©cnica:** Remediar vulnerabilidades seg√∫n SLA establecido

## üë• Roles y Responsabilidades

- **Desarrolladores Senior:** Mentorear en pr√°cticas de codificaci√≥n segura
- **Arquitectos de Software:** Definir patrones y bibliotecas seguras
- **Tech Leads:** Asegurar cumplimiento en revisiones de c√≥digo
- **Security Champions:** Promover adopci√≥n de est√°ndares en equipos
- **DevOps Engineers:** Configurar herramientas de an√°lisis autom√°tico
- **QA Engineers:** Validar implementaci√≥n de controles de seguridad

## üìä Cumplimiento y Medici√≥n

### M√©tricas de Cumplimiento
- Porcentaje de c√≥digo que pasa an√°lisis SAST sin vulnerabilidades cr√≠ticas/altas
- Tiempo promedio de remediaci√≥n de vulnerabilidades por severidad
- N√∫mero de vulnerabilidades detectadas en producci√≥n vs. desarrollo
- Cobertura de pruebas de seguridad en suite de testing

### Auditor√≠as
- Revisi√≥n mensual de m√©tricas de calidad de c√≥digo
- Auditor√≠as trimestrales de cumplimiento de est√°ndares
- Evaluaci√≥n anual de efectividad de controles implementados

## üö® Incumplimiento

El incumplimiento de este est√°ndar puede resultar en:
- Rechazo autom√°tico de pull requests que no cumplan criterios
- Reentrenamiento obligatorio en pr√°cticas de codificaci√≥n segura
- Revisi√≥n adicional de todo el c√≥digo del desarrollador
- Escalamiento a management para casos recurrentes
- Revocaci√≥n temporal de privilegios de commit para violaciones graves

## üìñ Referencias

- OWASP Top 10 Web Application Security Risks
- OWASP Secure Coding Practices Quick Reference
- CWE/SANS Top 25 Most Dangerous Software Errors
- NIST SP 800-218 Secure Software Development Framework
- ISO 27034 Application Security Management
- Mozilla Web Security Guidelines
- Google Web Fundamentals - Security
